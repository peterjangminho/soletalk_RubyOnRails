# Project_A vs Project_B 비교 보고서 (중학생도 이해할 수 있는 버전)

작성일: 2026-02-17  
목적: 지금 `Project_B -> Project_A` 작업을 계속할지, 아니면 `Project_B`로 돌아갈지 쉽게 이해하고 결정하기

---

## 0. 먼저 결론부터

### 추천 결론
1. **주력 개발은 Project_A를 계속하는 것이 맞다.**
2. 다만 **아주 빠르게 Android 음성 데모를 보여줘야 한다면**, Project_B를 잠깐 같이 쓰는 게 유리하다.

### 한 줄 요약
- **긴 호흡(제품 운영, 유지보수, 팀 협업)**: Project_A가 더 좋음  
- **짧은 호흡(즉시 Android 데모 품질)**: Project_B가 더 빠름

---

## 1. 아주 쉬운 비유로 이해하기

앱을 "가게"라고 생각해보면:

1. **Project_A**
- 새로 지은 가게
- 주방(서버) 구조가 깔끔하고, 규칙이 잘 정리됨
- 오래 운영하기 좋음

2. **Project_B**
- 이미 손님을 많이 받아본 가게
- 특히 "Android 음성" 요리는 아주 잘함
- 대신 주방이 2개(웹+네이티브)라 관리가 복잡함

즉:
- 당장 요리 하나 빨리 내야 하면 B
- 가게를 오래, 안정적으로 운영하려면 A

---

## 2. 어려운 단어 짧게 설명

1. 기술스택: 어떤 언어/프레임워크로 만들었는지  
2. 아키텍처: 앱 구조(방 설계도)  
3. 서버 중심: 중요한 로직이 서버에서 돌아감  
4. 하이브리드(WebView+Native): 웹 코드와 앱 코드를 같이 사용  
5. CI: 코드 올릴 때 자동 테스트해주는 검사기  
6. 유지보수: 시간이 지나도 고치기 쉬운 상태  

---

## 3. 두 프로젝트의 성격 차이

## Project_A (현재 목표에 더 맞는 구조)

1. Rails + Hotwire 기반
2. 서버 중심 단일 구조에 가까움
3. 인증/설정/배포/헬스체크 같은 운영 요소가 정리됨
4. 장기적으로 팀이 관리하기 쉬움

## Project_B (음성 엔진 완성도가 높은 자산)

1. React + TypeScript + Android Kotlin
2. WebView + Native 이중 구조
3. Android 음성 파이프라인과 관련 테스트 자산이 매우 큼
4. 기능은 강하지만 구조가 분산되어 운영 일관성 유지가 어려움

---

## 4. 숫자로 보는 현재 상태 (2026-02-17 기준)

## Project_A

1. 핵심 소스 파일: 약 **317개**
2. Ruby 코드량: 약 **11,780 LOC**
3. 테스트 파일: **94개**
4. 테스트 메서드: **207개**
5. TODO/FIXME/HACK: **0개**
6. 계획 체크리스트: **완료 246 / 미완료 1(외부 게이트)**
7. CI 워크플로우: **있음** (`.github/workflows/ci.yml`)

의미:
- "운영 가능한 제품 구조"가 잘 정리되어 있음

## Project_B

1. 핵심 소스 파일: 약 **1,168개**
2. TS/JS 코드량: 약 **36,248 LOC**
3. Android main Kotlin: **266 파일**
4. Android test Kotlin: **272 파일**
5. 전체 테스트 파일: **366개**
6. TODO/FIXME/HACK: **22개**
7. 저장소 내 CI 워크플로우: **없음**

의미:
- Android 음성 관련 "기술 자산"은 훨씬 큼
- 하지만 운영/배포 기준 정리 상태는 A보다 약함

---

## 5. 품질 관점에서 중요한 차이

## A의 강점

1. 서버/운영/배포 관점이 정리되어 있음
2. 서비스 객체 구조로 확장 포인트가 명확함
3. 장기 유지보수 비용이 낮아질 가능성이 큼

## A의 약점

1. 음성 대화 엔진 규칙이 아직 단순한 부분이 있음
2. Android 네이티브 트랙은 B보다 얕음

## B의 강점

1. Android 음성 파이프라인 완성도 높음
2. 복잡한 phase transition, narrowing, 오디오 제어 경험이 많이 쌓여 있음

## B의 약점

1. 구조가 나뉘어 있어(웹+네이티브) 바꾸면 같이 많이 고쳐야 함
2. 중장기 운영 관점에서 복잡도 부담이 큼

---

## 6. 왜 "A 주력 + B 참조"가 현실적인가?

이유는 간단함:

1. 제품 본체(운영/정책/배포/인증)는 A가 더 안정적
2. 음성 엔진 노하우(고급 규칙/Android 품질)는 B가 더 풍부
3. 그래서 **A를 메인으로 만들고, B에서 필요한 것만 뽑아오는 방식**이 가장 손해가 적음

즉, "코드를 통째로 옮기기"가 아니라 "좋은 아이디어/규칙을 옮기기"가 핵심

---

## 7. 목표별 선택 가이드

## 목표 1: 서비스 오래 운영할 앱 만들기

선택: **Project_A 계속**

이유:
1. 구조가 단순하고 팀 협업에 유리
2. 운영 자동화(CI/헬스체크 등) 기반이 이미 있음
3. 나중에 기능 추가할 때 덜 아픔

## 목표 2: 1~4주 안에 Android 음성 데모 완성도 극대화

선택: **Project_B 단기 병행**

이유:
1. 이미 Android 음성 자산이 많음
2. 바로 데모 성능/품질을 끌어올리기 쉬움

단, 주의:
1. 데모 후 다시 A 중심으로 돌아오는 계획이 반드시 필요

---

## 8. 실제로 이렇게 운영하면 좋다

## 권장 운영 방식

1. 메인 브랜치/본 제품: **Project_A**
2. Project_B 역할: **참조/실험 전용**

## B에서 A로 우선 옮길 것(로직만)

1. phase 전이 고급 규칙
2. narrowing 질문 전략
3. 음성 이벤트 처리 강화 규칙

## 옮기지 말아야 할 것

1. B의 구조 자체(WebView+Native 이중 구조) 복붙
2. B의 화면/흐름을 A에 그대로 이식하는 방식

---

## 9. 최종 답변 (질문에 직접 답)

질문: "계속 Project_A로 가는 게 맞나, 아니면 Project_B를 진행하는 게 맞나?"

답:
1. **기본 전략은 Project_A를 계속하는 것이 맞다.**
2. **Project_B는 버리는 게 아니라, 필요한 기술을 꺼내 쓰는 참고 저장소로 활용**하는 것이 가장 좋다.
3. **예외적으로 단기 Android 데모가 절대 우선일 때만** Project_B 비중을 일시적으로 높인다.

---

## 10. 참고한 근거 파일

## Project_A

1. `Gemfile`
2. `config/routes.rb`
3. `app/services/ontology_rag/client.rb`
4. `app/services/voice_chat/phase_transition_engine.rb`
5. `app/services/ops/preflight_check.rb`
6. `plan.md`
7. `.github/workflows/ci.yml`

## Project_B

1. `package.json`
2. `PLAN.md`
3. `services/phaseTransitionService.ts`
4. `services/contextOrchestrator.ts`
5. `android/app/src/main/kotlin/com/example/incarcompanion/domain/voicechat/VoiceChatManager.kt`

## 기존 종합 평가

1. `docs/ondev/20260212_04_comprehensive_migration_assessment.md`

---

## 11. 다음 행동 제안

1. A를 메인으로 고정하고, B에서 가져올 "로직 목록 10개"를 확정
2. 그 10개를 `TDD`로 A에 순서대로 이식
3. 각 이식 항목마다 "복붙 금지, 재작성 원칙"을 체크리스트로 관리

