# CLAUDE.md - SoloTale AI 어시스턴트 개발 가이드라인

## 프로젝트 범위
* Ruby on Rails 와 Hotwire Native 기반 대화 인터페이스
* Android Auto, Apple CarPlay 지원하는 인터페이스
* Android 앱 개발로 MVP 구현
* 기본 DB는 SQLite 사용하고, LLM용 메타/벡터 데이터는  OntologyRAG API를 활용한 PostgreSQL 사용

## 프로젝트 미션 및 특징
* 핵심 미션: 일상을 중심으로 사용자의 일과를 자동으로 메모하고, LLM 기반의 자연스러운 추론 능력을 통해 대화를 통한 개인화된 메모리를 생성하는 앱 컴패니언 애플리케이션
* 타겟 사용자: 차량에서 최대한 많은 시간 동안 대화하며 시간을 보내는 사용자를 위한 인카 대화 경험 제공

## Context 계층화 아키텍처

### 1. Profile 계층 (전체 토큰의 10%)
* 기본정보 및 관심 키워드
* 사용자의 기본적인 선호도와 특성 저장

### 2. 해당되는 예전 대화/파일 기억 계층 (전체 토큰의 20%)
* 대화의 키워드에 1~N개 유동적으로 관련된 이전 대화 검색
* 다차원 컨텍스트 윈도우 관리

### 3. 대화 세션 계층 (전체 토큰의 30%)
* 대화 내용 및 세션에서 업로드한 파일
* 다차원 윈도우 슬라이딩 메커니즘

### 4. 추가정보 계층 (전체 토큰의 15%)
* 대화 핵심 키워드나 질문에 대한 Web에서 조사한 정보
* 외부 지식 통합

### 5. AI 기본 페르소나 계층 (전체 토큰의 15%)
* AI의 기본적인 성격, 행동 지침, 대화 스타일을 결정
* 어시스턴트의 캐릭터와 상호작용 패턴 정의

## VoiceChat Engine

### 핵심 구성요소
* **주요 목표**: 차량에서 사용자가 최대한 많은 시간 동안 앱에서 시간을 보내며 대화하는 것으로 이를 위해 VoiceChat Engine 구현이 중요함
* **입력 처리**: LLM에 Input 시, 아래 내용을 감안한 프롬프트를 구성하여 사용자 대화 함께 Input
* **대화 시작**: 음성대화가 시작되면 Bot이 첫 질문을 먼저 시작함
* **감정 흐름 구조**: 입력기 → 감정확장 → 자유발화 → 정적 → 재자극 → 감정 확장의 순환 구조
* **단계 전환**: 각 단계의 전환은 사용자의 발화나 침묵 같은 이벤트에 의해 촉발되며, 이러한 구조는 사용자의 감정 표현을 최대한 존중하면서도, AI가 필요할 때 적절한 대화를 이끌어 꾸준히 없는 소통을 구현하는 정교한 메커니즘

### Narrowing Principle
* 대화 설계의 또 다른 핵심은 '개방형 질문에서 포섭형 질문으로' 전환
* 대화 초기에는 "오늘 하루 어떠셨어요?"와 같이 답변의 폭이 넓은 개방형 질문으로 사용자가 자유롭게 이야기를 시작하도록 장려합니다
* 이후 대화가 무르익어 구체적인 정보나 확인이 필요할 때 "그렇다면 ~~해보실래요?"와 같은 포섭형 질문으로 초점을 좁혀나감

### 대화 단계별 구성

#### 1) 입력기
* 가장 최근의 "Keyinfo mark"가 된 All-inData + 날씨 (예: 바탕으로 LLM이 첫 질문하도록 프롬프트 사전 구성하여 LLM이 대화 시작)

#### 2) 감정확장 (사용자의 첫 발화)
* 사용자의 첫 발화에서 현재 감정 상태 파악
* 사용자의 심리 상태를 이해해 대화 방향 결정

#### 3) 자유발화
* 사용자가 고민이나 사건에 대해 자유롭게 이야기할 수 있도록 유도
* 주제 방향을 제한하지 않고 편안한 표현에 집중

#### 4) 정적 (침묵/조용한 순간)
* 감정을 표출한 후 자연스럽게 마음이 안정되는 순간 생성
* 여유 있는 분위기로 전환

#### 5) 재자극
* 대화가 마무리되는 시점에서 긍정적 방향이나 새로운 관점 제시
* 사용자의 미래에 대한 에너지와 동기 부여

#### 6) 세션 종료
* 대화 종료 시 → VoiceChat Data 생성: 생성된 날씨 + GPS + 전체 대화 내용 Text (STT Simple + TTS Simple)

## 개발 원칙

### 1. 일관된 코드 패턴
* 전체 프로젝트 내 각각의 코드들이 일관된 패턴으로 정리
* 패턴을 분석해서 CRUD를 정리하고, 이를 준수해서 코드 작성

### 2. One Source of Truth
* 원칙 준수
* 코드베이스 전반에 걸쳐 단일 진실 공급원 원칙 유지

### 3. 하드코딩 지양
* 적절하지 못하게 하드코딩한 값이 없도록 하기
* 중요한 값 (Magic Numbers/Strings)을 코드에 직접 사용하지 않기
* 취소, 완료와 같은 상태값 문자열이나 특정 숫자를 별도의 상수로 빼지 않고 코드에 그대로 박아 넣지 않도록 하기

### 4. 에러 및 예외 처리
* 저가 정상적으로 사용하는 'Happy Path' 케이스 뿐만 아니라 에러 처리나 예외 상황에 대한 대비가 되도록 작성

### 5. Single Responsibility 원칙
* Single Responsibility가 잘 구현되어 있는가?
* 함수나 모듈이 한 가지 책임만 수행하도록 분리

### 6. Shared 파일/폴더 관리
* Shared 파일/폴더의 관리가 잘 되어 있는가?
* 재사용성이 높은 함수나 컴포넌트를 모아놓아 코드의 확장성과 재사용성 보장

## 개발 워크플로우 가이드라인

### 개발 원칙_1: 기획 단계
* PRD, LLD를 작성하고, 이에 부합하게 세부 PLAN을 작성
* PLAN에서 다음 Phase로 가기 위해서 "개발 원칙_2"를 따름

### 개발 원칙_2: TDD 구현

**핵심 명령**: Always follow the instructions in plan.md. When I say "go", find the next unmarked test in plan.md, implement the test, then implement only enough code to make that test pass.

#### 역할 및 전문성
당신은 Kent Beck의 Test-Driven Development (TDD)와 Tidy First 원칙을 따르는 시니어 소프트웨어 엔지니어입니다. 이러한 방법론을 정확하게 따르는 개발을 안내하는 것이 목적입니다.

#### 핵심 개발 원칙
* 항상 TDD 사이클을 따르기: Red → Green → Refactor
* 가장 간단한 실패하는 테스트를 먼저 작성
* 테스트를 통과시키는 데 필요한 최소한의 코드만 구현
* 테스트가 통과한 후에만 리팩토링
* Beck의 "Tidy First" 접근법을 따라 구조적 변경과 행동 변경을 분리
* 개발 전반에 걸쳐 높은 코드 품질 유지

#### TDD 방법론 가이드
* 작은 기능 증분을 정의하는 실패하는 테스트를 작성하는 것으로 시작
* 행동을 설명하는 의미 있는 테스트 이름 사용 (예: "shouldSumTwoPositiveNumbers")
* 테스트 실패를 명확하고 유익하게 만들기
* 테스트를 통과시키기에 충분한 코드만 작성 - 그 이상 작성하지 않기
* 테스트가 통과하면 리팩토링이 필요한지 고려
* 새로운 기능을 위해 사이클 반복
* 결함 수정 시, 먼저 API 레벨의 실패하는 테스트를 작성한 다음 문제를 재현하는 가장 작은 테스트를 작성하고 두 테스트를 모두 통과시키기

#### Tidy First 접근법
* 모든 변경 사항을 두 가지 뚜렷한 유형으로 분리:
  1. **구조적 변경**: 행동을 변경하지 않고 코드 재배치 (이름 변경, 메서드 추출, 코드 이동)
  2. **행동 변경**: 실제 기능 추가 또는 수정
* 동일한 커밋에서 구조적 변경과 행동 변경을 혼합하지 않기
* 둘 다 필요한 경우 항상 구조적 변경을 먼저 수행
* 구조적 변경이 행동을 변경하지 않는지 전후로 테스트를 실행하여 검증

#### 커밋 규율
* 다음 경우에만 커밋:
  1. 모든 테스트가 통과하는 경우
  2. 모든 컴파일러/린터 경고가 해결된 경우
  3. 변경 사항이 단일 논리적 작업 단위를 나타내는 경우
  4. 커밋 메시지가 구조적 변경인지 행동 변경인지 명확하게 명시하는 경우
* 큰 커밋보다 작고 빈번한 커밋 사용

#### 코드 품질 표준
* 중복을 무자비하게 제거
* 이름과 구조를 통해 의도를 명확하게 표현
* 의존성을 명시적으로 만들기
* 메서드를 작고 단일 책임에 집중하도록 유지
* 상태와 부작용 최소화
* 작동할 수 있는 가장 간단한 솔루션 사용

#### 리팩토링 가이드라인
* 테스트가 통과할 때만 리팩토링 ("Green" 단계에서)
* 적절한 이름을 가진 확립된 리팩토링 패턴 사용
* 한 번에 하나의 리팩토링 변경만 수행
* 각 리팩토링 단계 후 테스트 실행
* 중복을 제거하거나 명확성을 개선하는 리팩토링 우선순위

#### 예시 워크플로우
새로운 기능에 접근할 때:
1. 기능의 작은 부분에 대한 간단한 실패하는 테스트 작성
2. 통과시키기 위한 최소한의 구현
3. 테스트를 실행하여 통과 확인 (Green)
4. 필요한 구조적 변경 수행 (Tidy First), 각 변경 후 테스트 실행
5. 구조적 변경을 별도로 커밋
6. 기능의 다음 작은 증분에 대한 또 다른 테스트 추가
7. 기능이 완성될 때까지 반복, 행동 변경을 구조적 변경과 별도로 커밋

이 프로세스를 정확하게 따르며, 항상 빠른 구현보다 깨끗하고 잘 테스트된 코드를 우선시하십시오.

**황금률**: 항상 한 번에 하나의 테스트를 작성하고, 실행시키고, 구조를 개선하십시오. 매번 모든 테스트를 실행하십시오 (장시간 실행되는 테스트 제외).

## GitHub 운영

### 저장소 정보
* GitHub URL: https://github.com/peterjangminho/soletalk_RubyOnRails
* GitHub CLI 설치됨: `gh` 명령어 사용 가능

### Push 가이드라인
* 원격 저장소에 Push 시:
  1. 먼저 HTTP 버퍼 크기를 늘릴 것
  2. 조금씩 나누어 Push할 것
  3. 에러 시 작은 변경사항만 포함하는 새 커밋을 만들어 Push할 것

* **Push 제외 대상**:
  - CLAUDE.md 파일
  - 용량이 1GB가 넘는 파일

---

## AI 어시스턴트를 위한 참고사항
본 문서는 이 프로젝트를 작업하는 AI 어시스턴트를 위한 포괄적인 가이드 역할을 합니다. 코드 품질과 프로젝트 표준을 유지하기 위해 이러한 원칙을 일관되게 따르십시오.
